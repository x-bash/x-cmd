
# Policy Adding
___x_cmd_rmrf(){
    case "$1" in
        "")     ___x_cmd_rmrf_rule_ls; return ;;
        +)      shift; ___x_cmd_rmrf_rule_add "$@"; return ;;
        -)      shift; ___x_cmd_rmrf_rule_del "$@"; return ;;
        --)     ___x_cmd_rmrf_rule_clear; return ;;
    esac

    local i
    for i in "$@"; do
        # Using core:debug ...
        case "$i" in
            /)          printf "%s" "Try to 'rm -rf $i'" >&2 ;;
            /bin)       printf "%s" "Try to 'rm -rf $i'" >&2 ;;
            /usr)       printf "%s" "Try to 'rm -rf $i'" >&2 ;;
            /home)      printf "%s" "Try to 'rm -rf $i'" >&2 ;;
            /var)       printf "%s" "Try to 'rm -rf $i'" >&2 ;;
            *//*)       printf "%s" "Path consists of //. Variable expansion might not behave as you want." >&2 ;;
            *)          continue
        esac
        return 1
    done

    local code
    local rule
    local target
    if ! code="$(___x_cmd_rmrf___rule_check "$@")"; then
        echo "$code"
        eval "$code"
        x:error "Try to 'rm -rf $target'. Violation of rule: $rule"
        return 1
    fi

    command rm -rf "$@"
}

# Section: rule
___x_cmd_rmrf_rule_clear(){
    ___X_CMD_RMRF_RULE_LIST=
}

___x_cmd_rmrf_rule_add(){
    local IFS="
"
    ___X_CMD_RMRF_RULE_LIST="$___X_CMD_RMRF_RULE_LIST
$*
"
}

___x_cmd_rmrf_rule_ls(){
    printf "%s" "$___X_CMD_RMRF_RULE_LIST" | awk '{
        if ($0 == ""){ next; }
        print $0
    }'
}

___x_cmd_rmrf_rule_del(){
    local rule
    local tmp
    for rule in "$@"; do
        tmp="${___X_CMD_RMRF_RULE_LIST#*
$rule
}"
        if [ "$tmp" != "$___X_CMD_RMRF_RULE_LIST" ]; then
            x:info "Removing Rule: $rule"
            ___X_CMD_RMRF_RULE_LIST="${___X_CMD_RMRF_RULE_LIST%%
$rule
*}
${tmp}"
        else
            x:warn "Rule Not found: $rule"
        fi

    done
}

# EndSection


___x_cmd_rmrf___rule_check(){
    (
        local IFS="$___X_CMD_UNSEENCHAR_001"
        printf "%s\n" "$@"
        printf "%s\n" "$___X_CMD_RMRF_RULE_LIST"
    ) | (
        awk '
NR==1{
    patharrl = split( $1, patharr, "\001" )
}

NR>1{
    arr[ NR - 1 ] = $0
    r = $0
    gsub(/\*\*/, ".+", r)
    gsub(/\*/, "[^/]+", r)
    rule[ NR - 1 ] = r
}

END{
    arrl = NR - 1

    for (i=1; i<=patharrl; ++i) {
        p = patharr[ i ]
        for (j=1; j<=arrl; ++j) {
            if ( match( p, rule[j] ) ) {
                printf("rule=%s\n", arr[j])
                printf("target=\"$%s\"", i )
                exit(1)
            }
        }
    }
}

'
    )


}


# ___x_cmd_rmrf(){
#     local i
#     for i in "$@"; do
#         # Using core:debug ...
#         case "$i" in
#             /)          printf "%s" "Try to 'rm -rf $i'" >&2 ;;
#             /bin)       printf "%s" "Try to 'rm -rf $i'" >&2 ;;
#             /usr)       printf "%s" "Try to 'rm -rf $i'" >&2 ;;
#             /home)      printf "%s" "Try to 'rm -rf $i'" >&2 ;;
#             /var)       printf "%s" "Try to 'rm -rf $i'" >&2 ;;
#             *//*)       printf "%s" "Path consists of //. Variable expansion might not behave as you want." >&2 ;;
#             *)          continue
#         esac
#         return 1
#     done

#     command rm -rf "$@"
# }
