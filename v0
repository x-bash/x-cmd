# shellcheck shell=sh disable=SC3043

xrc log init xcmd

_x_mirror(){
    "https://x-cmd.github.io/x-official"
    "https://x-cmd.gitee.io/x-official"
}

___x_readlink_recursive(){
    if [ -L "${1:?Provide link}" ]; then
        local next_link
        next_link="$(readlink "${1}")" || return
        ___x_readlink_recursive "$next_link"
    else
        [ ! -e "${1}" ] || return 1        # File Not Exists
        printf "%s" "$1"
    fi
}

___x_readlink_recursive(){
    local next_link
    next_link="$(readlink "${1:?Provide link}")" && ___x_readlink_recursive "$next_link" && return
    [ -L "$1" ] && return 1     # Invalid link
    [ -e "$1" ] && printf "%s" "$1" && return 0
    return 1    # File not exists
}

# TODO: optimization. Consider sharing the big binary in a common folder.
# But that will introduce risk.
# How? 
# 1. Local user $HOME/.x-cmd
# 2. Global sharing folder.
# Consider using the sha512 to calculate the file hash for this purpose.

_x_official_which(){
    X_CMD_SRC_PATH="$HOME/.x-cmd"
    local target="${1:-Provide target path}"
    local cache="$X_CMD_SRC_PATH/$target"

    local target2="${target#@}"
    if [ "$target2" != "$target" ]; then
        target=target2
        cache="$X_CMD_SRC_PATH/___users/$target"
        echo "Not supported yet." >&2
        return 1
    fi

    if CACHE="$cache" _xrc_curl_gitx "$target" <<A
$(_x_mirror)
A
    then
        :
    fi

}

_x_xrc_run()(
    local name=$1;  shift
    xrc "$name"
    $name "$@"
)

# x py install/cdn

# xenv go in
# xenv j in
# xenv 

_x_header(){
    local filepath="${1:?filepath}"; shift
    case "$(head -n1 filepath)" in
        *python*)       x python "$@"         ;;
        *ruby*)         x python "$@"         ;;
        *node*)         x node "$@"           ;;
        *ts*)           x ts "$@"             ;;
        *)              return 127
    esac
}

_x_guest(){
    local filepath="${1:?filepath}"; shift
    local ext="${filepath##*.}"
    case "$ext" in
        py)     x python    "$filepath" "$@"      ;;
        rb)     x ruby      "$filepath" "$@"      ;;
        ts)     x ts        "$filepath" "$@"      ;;
        js)     x node      "$filepath" "$@"      ;;
        *)      return 126 ;;
    esac
}

_x_exe_workspace(){
    local filepath="${1:?filepath}"
    if [ -L "$filepath" ]; then
        local target_path
        target_path="$(dirname "$filepath")/$(readlink -f "$filepath")"
        filepath="$(cd "$(dirname "$target_path")" && pwd)/$(basename "$target_path")"
    fi

    # TODO: Hit enter twise will ignore this. But really, should we add this protection?
    if [ -z "$X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION" ]; then
        while true; do
            printf "%s" \
"=> Running file: $filepath ?
=> Press y to continue, n to abort. default is y: "

            read action
            case $action in
                n|no|nein|ne)  cat >&2 <<A
=> You could run the file by yourself:
\033[32m    x \"$filepath\" \033[;0m
A
                    return 1
                    ;;
                *)            printf "%s\n" "";     break ;;
            esac
        done
    fi

    shift
    if [ -x "$filepath" ]; then
        "$filepath" "$@"
        local code=$?
        # Bad interpreter
        if [ $code != 126 ] && [ $code != 127 ]; then
            _x_guest "$filepath" "$@"
            return
        fi
    fi

    _x_guest "$filepath" "$@"
    code=$?

    if [ $code = 126 ]; then
        if head -n1 "$filepath" | grep "\#\!" 1>/dev/null; then
            printf "=> \033[33m%s\033[0m:\n   %s\n\n" "Target file is NOT an executable file." "$filepath"
            local action
            while true; do
                printf "%s" "=> Change its mode to +x? (y/n, default is y)? " >&2
                read action
                case $action in
                    n|no|nein|ne)  cat <<A
=> Sorry. \033[31;1mCANNOT execute an non-executable file \033[0m. 
=> You could grant the permission as following:
\033[32m    chmod +x \"$filepath\" \033[;0m
A
                        return 1
                        ;;
                    *)
                        if [ "$action" = y ] || [ -z "$action" ]; then
                            if chmod +x "$filepath"; then
                                printf "\033[32m%s\033[0m\n\n" "Successfully grant execute permission." >&2
                                "$filepath" "$@"
                                return
                            else
                                local code=$?
                                printf "\033[31m%s\033[0m\n\n" "Failed to grant execute permission." >&2
                                return "$code"
                            fi
                        fi
                        continue ;;
                esac
            done
        fi

        if file "$filepath" | grep -iq "ASCII"; then
            cat "$filepath"
        else
            x hex "$filepath" "$@"
        fi
    fi

}


_x_run_service(){
    local filepath="${1:?filepath}"
    echo "https://kv.x-cmd.com/$filepath"
}

_x_prepare_src(){
    local filepath="${1:?filepath}"
    case "$filepath" in
        @github/*|@gh/*)             # using github service
            ;;
        @gt/*|@gitee/*)             # using github service
            ;;
        @x/*)
            _x_run_service "official/${filepath#@x/}" ;;
        @*/*)
            _x_run_service "${filepath#@}"            ;;
        http://*|https://*) 
            if [ -z "$NOWARN" ]; then
                echo "Sourcing script from unknown location: " "$RESOURCE_NAME"
                cat >&2 <<A
SECURITY WARNING! Sourcing script from unknown location: $RESOURCE_NAME
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
    > NOWARN=1 x "$filepath" "$@"

A
                printf "Input yes to continue. Otherwise exit > " >&2
                local input
                read input

                if [ "$input" != "yes" ]; then
                    echo "Exit becaause detect a non yes output: $input" >&2
                    return 1
                fi
            fi

            # TODO: change the BASE64-name
            TGT="$X_BASH_SRC_PATH/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" xrc_curl "$RESOURCE_NAME"; then
                xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            fi

            echo "$TGT"
            return 0
            ;;
        *)        
            local fp
            if fp=$(x search_path . "$filepath"); then
                # Slow down? Unknown malicious script. Is it in the whitelist?
                # - Put it in the whitelist: yes
                # - Reject: n
                # - Put this all files in .x-cmd in the whitelist? all
                _x_exe_workspace "$fp" "$@"
            else
                _x_run_service "$filepath" "$@"
            fi
            ;;
    esac
}

_x_run(){
    local filepath="${1:?filepath}";
    shift
    # @git/
    # @x/
    # x/work    # local filepath?
    # ./x-cmd   # how to
    case "$filepath" in
        @github/*|@gh/*)             # using github service
            ;;
        @gt/*|@gitee/*)             # using github service
            ;;
        @x/*|@official/*)
            _x_run_service "official/${filepath#@x/}" ;;
        @*/*)
            _x_run_service "${filepath#@}"            ;;
        http://*|https://*)
            if [ -z "$NOWARN" ]; then
                echo "Sourcing script from unknown location: " "$RESOURCE_NAME"
                cat >&2 <<A
SECURITY WARNING! Sourcing script from unknown location: $RESOURCE_NAME
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
    > NOWARN=1 x "$filepath" "$@"

A
                printf "Input yes to continue. Otherwise exit > " >&2
                local input
                read input

                if [ "$input" != "yes" ]; then
                    echo "Exit becaause detect a non yes output: $input" >&2
                    return 1
                fi
            fi

            # TODO: change the BASE64-name
            TGT="$X_BASH_SRC_PATH/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" xrc_curl "$RESOURCE_NAME"; then
                xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            fi

            echo "$TGT"
            return 0
            ;;
        # *:*)   # for ssh  ;;
        *)        
            local fp
            if fp=$(x search_path . "$filepath"); then
                # Slow down? Unknown malicious script. Is it in the whitelist?
                # - Put it in the whitelist: yes
                # - Reject: n
                # - Put this all files in .x-cmd in the whitelist? all
                _x_exe_workspace "$fp" "$@"
            else
                _x_run_service "$filepath" "$@"
            fi
            ;;
    esac
}

xrc x-cmd/_v0/node
xrc x-cmd/_v0/python
# . _v0/node
# . _v0/python

x(){
    local subcmd=$1;    shift
    case "$subcmd" in
        rc|src) SRC_LOADER=bash eval "$(_xrc_print_code "$@")" ;;
        z)  (   xrc zuz && zuz z "$@"   )   ;;
        uz) (   xrc zuz && zuz uz "$@" )    ;;
        ubu|alp|deb|cen|bus) (
            xrc xdk
            xdk "$@"
        ) ;;
        docker|dk|xdk) (
            xrc xdk
            xdk "$@"
        ) ;;
        # java | jar);;
        nvm)
            xrc nvm/v0
            nvm "$@"
        ;;

        pip|pip3)
            _x_pip3 "$@"
            ;;
        python|py|python3|py3)
            # Install python using pyenv
            # xrc pyenv
            # _x_python3 "$(_x_official_which "$2")" "$@"     
            _x_python3 "$@"
            ;;
        javascript|js|node)
            _x_node "$@"
            # # Install node using nvm
            # if command -v node 2>/dev/null 1>&2; then
            #     node "$(_x_official_which "$2")" "$@"     
            # else
            #     (
            #         xrc nvm/v0
            #         nvm install lts/*
            #     )
            #     nvm run --lts "$@"
            # fi
            ;;
        npm)        _x_npm "$@" ;;
        ts)
            local arg
            local argstr
            while [ $# -ge 0 ]; do
                case "$arg" in
                    -*)     argstr="$argstr $arg"   ;;
                    *)      break
                esac
            done
            local script
            # script="$(_x_official_which "$1")"
            script="$1"
            shift
            eval 民 "$argstr" "$script" "$@"
            ;;
        ruby|rb)
            ruby "$(_x_official_which "$2")" "$@"     ;;
        lua)
            ;;
        7zr)            ( xrc p7zr/v0   &&  p7zr "$@" ) ;;
        7z)             ( xrc p7z/v0    &&  p7z "$@" ) ;;
        ls)             _x_xrc_run exa   "$@" ;;
        ll)             x ls -l "$@" ;;

        ps|procs)       _x_xrc_run procs    "$@" ;;
        du|dust)        _x_xrc_run dust     "$@" ;;
        bat|cat)        _x_xrc_run bat      "$@" ;;
        bw)             _x_xrc_run bw       "$@" ;;

        run)
            local fp="$1"; shift 1
            case "$fp" in
                *.py)       x python            "$fp" "$@"    ;;
                *.rb)       x ruby              "$fp" "$@"    ;;
                *.lua)      x lua               "$fp" "$@"    ;;
                *.ts)       x ts                "$fp" "$@"    ;;
                *)          _x_exe_workspace    "$fp" "$@"    ;;
            esac
            ;;
        search_path)
            local cur="${1:?Provide starting path}"
            local relative_filepath="${2:?Provide relative filepath}"
            while [ ! "$cur" = "" ]; do
                if [ -f "$cur/$relative_filepath" ]; then
                    echo "$cur"
                    return 0
                fi
                cur=${cur%/*}
            done
            return 1
            ;;
        which|w)
            local p
            local relative_path
            for relative_path in "$@"; do
                xcmd_log debug "Relative Path: $relative_path"
                if p="$(x search_path "$(pwd)" ".x-cmd/$relative_path")"; then
                    echo "$p/.x-cmd/$relative_path"
                    return 0
                else
                    continue
                fi
            done
            ;;
        *)
            local p
            if p="$(x which "$subcmd")"; then
                _x_exe_workspace "$p" "$@"
                return
            fi

            echo "$p"

            # if [ -z "$X_CMD_PATH" ] && ! X_CMD_PATH="$(command -v x)"; then
            #     if ! eval "$(curl https://get.x-cmd.com/x-cmd-binary)" || ! X_CMD_PATH="$(command -v x)"; then
            #         echo "Installation of x-cmd binary failed. Please retry again." >&2
            #         return 1
            #     fi
            # fi
            # "$X_CMD_PATH" "$@"  ;;
    esac
}

# if [ ! "$#" = 0 ]; then
#     x "$@"
# fi
