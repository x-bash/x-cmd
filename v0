# shellcheck shell=sh disable=SC3043

xrc log init xcmd

___xcmd_readlink_recursive(){
    if [ -L "${1:?Provide link}" ]; then
        local next_link
        next_link="$(readlink "${1}")" || return
        if [ "${next_link#/}" = "$next_link" ]; then
            next_link="$(dirname "${1}")/$next_link"
        fi
        ___xcmd_readlink_recursive "$next_link"
    else
        [ ! -e "${1}" ] && return 1        # File Not Exists
        printf "%s" "$1"
    fi
}


# Section : Unfinished ___xcmd_official_which

___x_mirror(){
    "https://x-cmd.github.io/x-official"
    "https://x-cmd.gitee.io/x-official"
}

# TODO: optimization. Consider sharing the big binary in a common folder.
# But that will introduce risk.
# How?
# 1. Local user $HOME/.x-cmd
# 2. Global sharing folder.
# Consider using the sha512 to calculate the file hash for this purpose.

___xcmd_official_which(){
    X_CMD_SRC_PATH="$HOME/.x-cmd"
    local target="${1:-Provide target path}"
    local cache="$X_CMD_SRC_PATH/$target"

    local target2="${target#@}"
    if [ "$target2" != "$target" ]; then
        target=target2
        cache="$X_CMD_SRC_PATH/___users/$target"
        echo "Not supported yet." >&2
        return 1
    fi

    if CACHE="$cache" _xrc_curl_gitx "$target" <<A
$(___x_mirror)
A
    then
        :
    fi

}

# EndSection

# Section : Utitilies

___x_header(){
    local filepath="${1:?filepath}"; shift
    case "$(head -n1 filepath)" in
        *python*)       xcmd python "$@"         ;;
        *ruby*)         xcmd python "$@"         ;;
        *node*)         xcmd node "$@"           ;;
        *ts*)           xcmd ts "$@"             ;;
        *)              return 127
    esac
}

___x_guest(){
    local filepath="${1:?filepath}"; shift
    local ext="${filepath##*.}"
    case "$ext" in
        py)     xcmd python    "$filepath" "$@"      ;;
        rb)     xcmd ruby      "$filepath" "$@"      ;;
        ts)     xcmd ts        "$filepath" "$@"      ;;
        js)     xcmd node      "$filepath" "$@"      ;;
        *)      return 126 ;;
    esac
}

___xcmd_abspath(){
    local target_path="${1:-Please provide path}"
    # $(dirname "$filepath")/
    if [ "${target_path#/}" = "${target_path}" ]; then
        printf "%s" "$(cd "$(dirname "$target_path")" && pwd)/$(basename "$target_path")"
    else
        printf "%s" "$target_path"
    fi
}

# EndSection

# Section : Find And Execute at .x-cmd folder

___x_exe_workspace(){
    local filepath="${1:?filepath}"
    if [ -L "$filepath" ]; then
        local target_path
        target_path="$(___xcmd_readlink_recursive "$filepath")"
        target_path="$(___xcmd_abspath "$target_path")"
    fi

    # TODO: Hit enter twise will ignore this. But really, should we add this protection?
    if [ -z "$X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION" ]; then
        while true; do
            printf "%s" \
"=> Running file: $filepath ?
=> Enter or press y to continue, n to abort. default is y: "

            read action
            case $action in
                n|no|nein|ne)  cat >&2 <<A
=> You could run the file by yourself:
\033[32m    xcmd \"$filepath\" \033[;0m
A
                    return 1
                    ;;
                ""|y)            printf "%s\n" "";     break ;;
            esac
        done
    fi

    shift
    if [ -x "$filepath" ]; then
        "$filepath" "$@"
        local code=$?
        # Bad interpreter
        if [ $code != 126 ] && [ $code != 127 ]; then
            ___x_guest "$filepath" "$@"
            return
        fi
    fi

    ___x_guest "$filepath" "$@"
    code=$?

    if [ $code = 126 ]; then
        if head -n1 "$filepath" | grep "\#\!" 1>/dev/null; then
            printf "=> \033[33m%s\033[0m:\n   %s\n\n" "Target file is NOT an executable file." "$filepath"
            local action
            while true; do
                printf "%s" "=> Change its mode to +x? (y/n, default is y)? " >&2
                read action
                case $action in
                    n|no|nein|ne)  cat <<A
=> Sorry. \033[31;1mCANNOT execute an non-executable file \033[0m.
=> You could grant the permission as following:
\033[32m    chmod +x \"$filepath\" \033[;0m
A
                        return 1
                        ;;
                    *)
                        if [ "$action" = y ] || [ -z "$action" ]; then
                            if chmod +x "$filepath"; then
                                printf "\033[32m%s\033[0m\n\n" "Successfully grant execute permission." >&2
                                "$filepath" "$@"
                                return
                            else
                                local code=$?
                                printf "\033[31m%s\033[0m\n\n" "Failed to grant execute permission." >&2
                                return "$code"
                            fi
                        fi
                        continue ;;
                esac
            done
        fi

        if file "$filepath" | grep -iq "ASCII"; then
            cat "$filepath"
        else
            xcmd hex "$filepath" "$@"
        fi
    fi

}

# EndSection

_____x_run_service(){
    local filepath="${1:?filepath}"
    echo "https://kv.x-cmd.com/$filepath"
}

___x_prepare_src(){
    local filepath="${1:?filepath}"
    case "$filepath" in
        @github/*|@gh/*)             # using github service
            ;;
        @gt/*|@gitee/*)             # using github service
            ;;
        @x/*)
            _____x_run_service "official/${filepath#@x/}" ;;
        @*/*)
            _____x_run_service "${filepath#@}"            ;;
        http://*|https://*)
            if [ -z "$NOWARN" ]; then
                echo "Sourcing script from unknown location: " "$RESOURCE_NAME"
                cat >&2 <<A
SECURITY WARNING! Sourcing script from unknown location: $RESOURCE_NAME
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
    > NOWARN=1 xcmd "$filepath" "$@"

A
                printf "Input yes to continue. Otherwise exit > " >&2
                local input
                read input

                if [ "$input" != "yes" ]; then
                    echo "Exit becaause detect a non yes output: $input" >&2
                    return 1
                fi
            fi

            # TODO: change the BASE64-name
            TGT="$X_BASH_SRC_PATH/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" xrc_curl "$RESOURCE_NAME"; then
                xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            fi

            echo "$TGT"
            return 0
            ;;
        *)
            local fp
            if fp=$(x search_path . "$filepath"); then
                # Slow down? Unknown malicious script. Is it in the whitelist?
                # - Put it in the whitelist: yes
                # - Reject: n
                # - Put this all files in .x-cmd in the whitelist? all
                ___x_exe_workspace "$fp" "$@"
            else
                _____x_run_service "$filepath" "$@"
            fi
            ;;
    esac
}

___x_run(){
    local filepath="${1:?filepath}";
    shift
    # @git/
    # @x/
    # x/work    # local filepath?
    # ./x-cmd   # how to
    case "$filepath" in
        @github/*|@gh/*)             # using github service
            ;;
        @gt/*|@gitee/*)             # using github service
            ;;
        @x/*|@official/*)
            _____x_run_service "official/${filepath#@x/}" ;;
        @*/*)
            _____x_run_service "${filepath#@}"            ;;
        http://*|https://*)
            if [ -z "$NOWARN" ]; then
                echo "Sourcing script from unknown location: " "$RESOURCE_NAME"
                cat >&2 <<A
SECURITY WARNING! Sourcing script from unknown location: $RESOURCE_NAME
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
    > NOWARN=1 xcmd "$filepath" "$@"

A
                printf "Input yes to continue. Otherwise exit > " >&2
                local input
                read input

                if [ "$input" != "yes" ]; then
                    echo "Exit becaause detect a non yes output: $input" >&2
                    return 1
                fi
            fi

            # TODO: change the BASE64-name
            TGT="$X_BASH_SRC_PATH/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" xrc_curl "$RESOURCE_NAME"; then
                xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            fi

            echo "$TGT"
            return 0
            ;;
        # *:*)   # for ssh  ;;
        *)
            local fp
            if fp=$(x search_path . "$filepath"); then
                # Slow down? Unknown malicious script. Is it in the whitelist?
                # - Put it in the whitelist: yes
                # - Reject: n
                # - Put this all files in .x-cmd in the whitelist? all
                ___x_exe_workspace "$fp" "$@"
            else
                _____x_run_service "$filepath" "$@"
            fi
            ;;
    esac
}


# Section : utilties in static-build
xrc static-build

# _x_xrc_run()(
#     local name=$1;  shift
#     xrc "$name"
#     $name "$@"
# )

# _x_xrc_static_run(){
#     local name=$1;  shift
#     xrc static-build
#     static_build_xrc "$name"
#     "_${name}_bin" "$@"
# }

___xcmd_jq(){
    static_build_init jq jq ___xcmd_jq && ___xcmd_jq          "$@"
}

___xcmd_bw(){
    static_build_init bw bw ___xcmd_bw && ___xcmd_bw          "$@"
}

___xcmd_exa(){
    static_build_init exa exa ___xcmd_exa && ___xcmd_exa      "$@"
}

___xcmd_dust(){
    static_build_init dust dust ___xcmd_dust && ___xcmd_dust  "$@"
}

___xcmd_procs(){
    static_build_init procs procs ___xcmd_procs && ___xcmd_procs  "$@"
}

___xcmd_bat(){
    static_build_init bat bat ___xcmd_bat && ___xcmd_bat      "$@"
}

# EndSection


# Section : Runtime
xrc x-cmd/_v0/node
xrc x-cmd/_v0/python
# . _v0/node
# . _v0/python

# EndSection


# Section : xcmd main function

xcmd(){
    local subcmd=$1;    shift
    case "$subcmd" in
        rc|src) SRC_LOADER=bash eval "$(_xrc_print_code "$@")" ;;
        z)  (   xrc zuz && zuz z "$@"   )   ;;
        uz) (   xrc zuz && zuz uz "$@" )    ;;
        ubu|alp|deb|cen|bus) (  xrc xdk;        xdk "$@";    ) ;;
        docker|dk|xdk) (
            xrc xdk
            xdk "$@"
        ) ;;
        # java | jar);;
        nvm)
            xrc nvm/v0
            nvm "$@"
        ;;

        pip|pip3)
            _x_pip3 "$@"
            ;;
        python|py|python3|py3)
            _x_python3 "$@"
            ;;
        javascript|js|node)
            _x_node "$@"
            ;;
        npm)        _x_npm "$@" ;;
        ts)
            local arg
            local argstr
            while [ $# -ge 0 ]; do
                case "$arg" in
                    -*)     argstr="$argstr $arg"   ;;
                    *)      break
                esac
            done
            local script
            # script="$(___xcmd_official_which "$1")"
            script="$1"
            shift
            eval "$argstr" "$script" "$@"
            ;;
        ruby|rb)
            ruby "$(___xcmd_official_which "$2")" "$@"     ;;
        lua)
            ;;
        7zr)            ( xrc p7zr/v0   &&  p7zr "$@" ) ;;
        7z)             ( xrc p7z/v0    &&  p7z "$@" ) ;;
        ls)             ___xcmd_exa        "$@" ;;
        ll)             ___xcmd_exa  -l    "$@" ;;

        ps|procs)       ___xcmd_procs      "$@" ;;
        du|dust)        ___xcmd_dust       "$@" ;;
        bat|cat)        ___xcmd_bat        "$@" ;;
        bw)             ___xcmd_bw         "$@" ;;
        jq)             ___xcmd_jq         "$@" ;;

        run)
            local fp="$1"; shift 1
            case "$fp" in
                *.py)       xcmd python            "$fp" "$@"    ;;
                *.rb)       xcmd ruby              "$fp" "$@"    ;;
                *.lua)      xcmd lua               "$fp" "$@"    ;;
                *.ts)       xcmd ts                "$fp" "$@"    ;;
                *)          ___x_exe_workspace    "$fp" "$@"    ;;
            esac
            ;;
        search_path)
            local cur="${1:?Provide starting path}"
            local relative_filepath="${2:?Provide relative filepath}"
            while [ ! "$cur" = "" ]; do
                if [ -f "$cur/$relative_filepath" ]; then
                    printf "%s" "$cur"
                    return 0
                fi
                cur=${cur%/*}
            done
            return 1
            ;;
        which|w)
            local p
            local relative_path
            for relative_path in "$@"; do
                xcmd_log debug "Relative Path: $relative_path"
                if p="$(x search_path "$(pwd)" ".x-cmd/$relative_path")"; then
                    printf "%s" "$p/.x-cmd/$relative_path"
                    return 0
                else
                    continue
                fi
            done
            ;;
        *)
            local p
            if p="$(x which "$subcmd")"; then
                ___x_exe_workspace "$p" "$@"
                return
            fi

            printf "%s" "$p"

            # if [ -z "$X_CMD_PATH" ] && ! X_CMD_PATH="$(command -v x)"; then
            #     if ! eval "$(curl https://get.x-cmd.com/x-cmd-binary)" || ! X_CMD_PATH="$(command -v x)"; then
            #         echo "Installation of x-cmd binary failed. Please retry again." >&2
            #         return 1
            #     fi
            # fi
            # "$X_CMD_PATH" "$@"  ;;
    esac
}

# EndSection

x(){
    xcmd "$@"
}

if [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]; then
    xrc advise/v0
    advise x
fi



