# shellcheck shell=sh disable=SC3043


_x_search_path(){
    local cur="${1:?Provide starting path}"
    local relative_filepath="${2:?Provide relative filepath}"
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/.x-cmd/$relative_filepath" ]; then
            echo "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}

_x_mirror(){
    "https://x-cmd.github.io/x-official"
    "https://x-cmd.gitee.io/x-official"
}

# TODO: optimization. Consider sharing the big binary in a common folder.
# But that will introduce risk.
# How? 
# 1. Local user $HOME/.x-cmd
# 2. Global sharing folder.
# Consider using the sha512 to calculate the file hash for this purpose.

_x_official_which(){
    X_CMD_SRC_PATH="$HOME/.x-cmd"
    local target="${1:-Provide target path}"
    local cache="$X_CMD_SRC_PATH/$target"

    local target2="${target#@}"
    if [ "$target2" != "$target" ]; then
        target=target2
        cache="$X_CMD_SRC_PATH/___users/$target"
        echo "Not supported yet." >&2
        return 1
    fi

    if CACHE="$cache" _xrc_curl_gitx "$target" <<A
$(_x_mirror)
A
    then
        :
    fi

}

_x_xrc_run()(
    local name=$1;  shift
    xrc "$name"
    $name ${1:+"$@"}
)

# x py install/cdn

# xenv go in
# xenv j in
# xenv 

_x_header(){
    local filepath="${1:?filepath}"; shift
    case "$(head -n1 filepath)" in
        *python*)       x python ${1:+"$@"}         ;;
        *ruby*)         x python ${1:+"$@"}         ;;
        *node*)         x node ${1:+"$@"}           ;;
        *ts*)           x ts ${1:+"$@"}             ;;
        *)              return 127
    esac
}

_x_guest(){
    local filepath="${1:?filepath}"; shift
    local ext="${filepath##*.}"
    case "$ext" in
        py)     x python    "$filepath" ${1:+"$@"}      ;;
        rb)     x ruby      "$filepath" ${1:+"$@"}      ;;
        ts)     x ts        "$filepath" ${1:+"$@"}      ;;
        js)     x node      "$filepath" ${1:+"$@"}      ;;
        *)      return 126 ;;
    esac
}

_x_exe(){
    local filepath="${1:?filepath}"
    if [ -L "$filepath" ]; then
        local target_path
        target_path="$(dirname "$filepath")/$(readlink -f "$filepath")"
        filepath="$(cd "$(dirname "$target_path")" && pwd)/$(basename "$target_path")"
    fi

    shift
    if [ -x "$filepath" ]; then
        "$filepath" ${1:+"$@"}
        local code=$?

        if [ $code != 126 ] && [ $code != 127 ]; then
            _x_guest "$filepath" ${1:+"$@"}
            return
        fi
    fi

    if _x_guest "$filepath" ${1:+"$@"}; then
        if [ $? = 126 ]; then
            if file "$filepath" | grep -iq "ASCII"; then
                cat "$filepath"
            else
                x hex "$filepath" ${1:+"$@"}
            fi
        fi
    fi

}


_x_run_service(){
    local filepath="${1:?filepath}"
    echo "https://kv.x-cmd.com/$filepath"
}

_x_run(){
    local filepath="${1:?filepath}";
    shift
    # @git/
    # @x/
    # x/work    # local filepath?
    # ./x-cmd   # how to
    case "$filepath" in
        @github/*|@gh/*)             # using github service
            ;;
        @gt/*|@gitee/*)             # using github service
            ;;
        @x/*)
            _x_run_service "official/${filepath#@x/}" ;;
        @*/*)
            _x_run_service "${filepath#@}"            ;;
        http://*|https://*) 
            # Slow down? 
            # - Unknown script. May contains malicous code. Is it in the whitelist. SHA512 in the whitelist.
            # - Unknown script. 
            ;;
        # *:*)
        #     # for ssh
        #     ;;
        *)        
            local fp
            if fp=$(_x_uproot_find . "$filepath"); then
                # Slow down? Unknown malicious script. Is it in the whitelist?
                # - Put it in the whitelist: yes
                # - Reject: n
                # - Put this all files in .x-cmd in the whitelist? all
                _x_exe "$fp" ${1:+"$@"}
            else
                _x_run_service "$filepath" ${1:+"$@"}
            fi
            ;;
    esac
}

_x_uproot_find(){
    local cur="${1:?Provide starting path}"
    local relative_filepath="${2:?Provide relative filepath}"
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/$relative_filepath" ]; then
            echo "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}

x(){
    case "${1:?Provide Sub Command}" in
        rc|src) SRC_LOADER=bash eval "$(_xrc_print_code "$@")" ;;
        # java | jar);;

        ubu|alp|deb|cen|bus) (
                xrc xdk
                xdk ${1:+"$@"}
            ) ;;
        docker|dk|xdk) (
                xrc xdk
                shift 1
                xdk ${1:+"$@"}
            ) ;;
        python|py) 
            shift;
            # Install python using pyenv
            # xrc pyenv
            python "$(_x_official_which "$2")" "$@"     ;;
        javascript|js)
            shift;
            # Install node using nvm
            node "$(_x_official_which "$2")" "$@"       ;;
        typescript|ts)
            shift;
            # Install node using nvm
            ts-node "$(_x_official_which "$2")" "$@"    ;;
        ruby|rb)
            shift;
            python "$(_x_official_which "$2")" "$@"     ;;
        lua)
            shift
            ;;
        7z)
            shift
            ( 
                xrc p7z
                p7z ${1:+"$@"}
            ) ;;
        ps|procs)
            shift;  _x_xrc_run procs "$@" ;;
        du|dust)
            shift;  _x_xrc_run dust  "$@" ;;
        ls)
            shift;  _x_xrc_run exa   "$@" ;;
        ll)
            shift;  x ls -l ${1:+"$@"} ;;
        bat|cat)
            shift;  _x_xrc_run bat   "$@" ;;
        bw)
            shift;  _x_xrc_run bw   "$@" ;;
        exe)
            if [ ! -x "$fp" ]; then
                printf "=> \033[33m%s\033[0m:\n   %s\n\n" "Target file is NOT an excuatable" "$fp"
                local action
                while true; do
                    printf "%s" "=> Change its mode to +x? (y/n, default is y)? " >&2
                    read action
                    case $action in
                        y)  if chmod +x "$fp"; then
                                printf "\033[32m%s\033[0m\n\n" "Successfully grant execute permission." >&2
                            else
                                local code=$?
                                printf "\033[31m%s\033[0m\n\n" "Failed to grant execute permission." >&2
                                return "$code"
                            fi
                            break ;;
                        n)  echo -e "
=> Sorry. \033[31;1mCANNOT execute an non-executable file \033[0m. You could grant the permission as following:
\033[32m    chmod +x \"$fp\" \033[;0m
"
                            return 1  
                            ;;
                        "") chmod +x "$fp" ;;
                        *)  continue ;;
                    esac
                done
            fi
            "$fp" ${1:+"$@"}            
            ;;
        run)
            local fp="$2"; shift 2
            case "$fp" in
                *.py)       x python "$fp" ${1:+"$@"}   ;;
                *.rb)       x ruby "$fp" ${1:+"$@"}     ;;
                *.lua)      x lua "$fp" ${1:+"$@"}      ;;
                *.ts)       x ts "$fp" ${1:+"$@"}       ;;
                *)          x exe "$fp" ${1:+"$@"}      ;;
            esac
            ;;
        *)  
            local p
            local relative_path="$1"
            if p="$(_x_search_path "$(pwd)" "$relative_path")"; then
                shift
                _x_exe "$p/.x-cmd/$relative_path" ${1:+"$@"}
                return 0
            fi

            echo "$p"

            # if [ -z "$X_CMD_PATH" ] && ! X_CMD_PATH="$(command -v x)"; then
            #     if ! eval "$(curl https://get.x-cmd.com/x-cmd-binary)" || ! X_CMD_PATH="$(command -v x)"; then
            #         echo "Installation of x-cmd binary failed. Please retry again." >&2
            #         return 1
            #     fi
            # fi
            # "$X_CMD_PATH" "$@"  ;;
    esac
}

if [ ! "$#" = 0 ]; then
    x "$@"
fi
